heat_template_version: rocky
  
description: >
  Cisco ACI Opflex-agent containerized service

parameters:
  ContainerOpflexAgentImage:
    description: image
    type: string
  ServiceData:
    default: {}
    description: Dictionary packing service data
    type: json
  ServiceNetMap:
    default: {}
    description: Mapping of service_name -> network name. Typically set
                 via parameter_defaults in the resource registry.  This
                 mapping overrides those in ServiceNetMapDefaults.
    type: json
  DefaultPasswords:
    default: {}
    type: json
  RoleName:
    default: ''
    description: Role name on which the service is applied
    type: string
  RoleParameters:
    default: {}
    description: Parameters specific to the role
    type: json
  EndpointMap:
    default: {}
    description: Mapping of service endpoint -> protocol. Typically set
                 via parameter_defaults in the resource registry.
    type: json
  UpgradeRemoveUnusedPackages:
    default: false
    description: Remove package if the service is being disabled during upgrade
    type: boolean
  ACIOpflexUplinkInterface:
    type: string
    default: 'nic1'
  ACIApicInfraVlan:
    type: number
    default: 4093
  ACIOpflexInterfaceType:
    type: string
    default: 'linux'
    description: >
      Valid values are 'linux' or 'ovs'. This determines whether the infra vlan interface
      is created as a linux interface or an OVS interface. For openshift on openstack, the
      interface should be a OVS interface.
  ACIEnableBondWatchService:
    type: boolean
    default: false
    description: Enable and start apic-bond-watch service
  ACIApicSystemId:
    type: string
    default: 'aci_openstack'
  ACIOpflexDisabledFeatures:
    type: comma_delimited_list
    default: ""
    description: >
      Valid values are "erspan". This determines whether a given feature is supported
      by the vSwitch in the underlying distribution, and therefore can be enabled in the
      opflex-agent.
  ACIOpflexInterfaceMTU:
    type: number
    default: 1600
  ACIOpflexBridgeToPatch:
    type: string
    default: 'br-ex'
    description: >
     When opflex is used in VLAN encap mode, the interface connected to ACI fabric should
     be part of integration bridge br-int. In some network configuration, the interface could
     already be part of other bridge for example br-ex. Setting this value to br-ex will create
     a patch interface between br-int and br-ex. If set to empty string, no patch will be created
  ACIOpflexEncapMode:
    type: string
    default: 'vxlan'
    constraints:
      - allowed_values: ['vlan', 'vxlan']
  OpflexEndpointReqTimeout:
    default: 10
    type: number
  OpflexNatMtuSize:
    default: 0
    type: number
  OpflexLoggingLevel:
    default: debug2
    type: string
  NeutronExternalBridge:
    type: string
    default: 'br-ex'
    description: >
       Opflex depends on knowing what the external bridge name is, which by default is br-ex
       If neutron configuration was changed to some other name, this variable needs to be set
       to the same value.
  ACIApicInfraSubnetGateway:
    type: string
    default: '10.0.0.30'
  ACIApicInfraAnycastAddr:
    type: string
    default: '10.0.0.32'
resources:
  ContainersCommon:
    type: /usr/share/openstack-tripleo-heat-templates/deployment/containers-common.yaml

outputs:
  role_data:
    description: Role data for the Opflex agent service.
    value:
      service_name: opflex_agent
      config_settings:
        map_merge:
        - ciscoaci::opflex::aci_opflex_uplink_interface: {get_param: ACIOpflexUplinkInterface}
        - ciscoaci::opflex::aci_apic_infravlan: {get_param: ACIApicInfraVlan}
        - ciscoaci::opflex::opflex_interface_type: {get_param: ACIOpflexInterfaceType}
        - ciscoaci::opflex::aci_apic_systemid: {get_param: ACIApicSystemId}
        - ciscoaci::opflex::opflex_disabled_features: {get_param: ACIOpflexDisabledFeatures}
        - ciscoaci::opflex::opflex_enable_bond_watch: {get_param: ACIEnableBondWatchService}
        - ciscoaci::opflex::aci_opflex_encap_mode: {get_param: ACIOpflexEncapMode}
        - ciscoaci::opflex::aci_apic_infra_subnet_gateway: {get_param: ACIApicInfraSubnetGateway}
        - ciscoaci::opflex::aci_apic_infra_anycast_address: {get_param: ACIApicInfraAnycastAddr}
        - ciscoaci::opflex::opflex_target_bridge_to_patch: {get_param: ACIOpflexBridgeToPatch}
        - ciscoaci::opflex::opflex_interface_mtu: {get_param: ACIOpflexInterfaceMTU}
        - ciscoaci::opflex::neutron_external_bridge: {get_param: NeutronExternalBridge}
        - ciscoaci::opflex::opflex_log_level: {get_param: OpflexLoggingLevel}
      puppet_config:
        config_volume: opflex
        puppet_tags: opflex_config
        step_config: |
          include ::tripleo::profile::base::ciscoaci_opflex
        config_image: {get_param: ContainerOpflexAgentImage}
        # We need to mount /run for puppet_config step. This is because
        # puppet-vswitch runs the commands "ovs-vsctl list open_vswitch ."
        # when running vswitch::ovs::enable_hw_offload: true
        # ovs-vsctl talks to the ovsdb-server (hosting conf.db)
        # on the unix domain socket - /run/openvswitch/db.sock
        volumes:
          - /lib/modules:/lib/modules:ro
          - /run/openvswitch:/run/openvswitch:shared,z
          - /etc/os-net-config:/etc/os-net-config:ro
      kolla_config:
        /var/lib/kolla/config_files/ciscoaci_opflex_agent.json:
          command: /bin/supervisord -c /etc/opflex-agent-ovs/opflex_supervisord.conf
          config_files:
            - source: "/var/lib/kolla/config_files/src/*"
              dest: "/"
              merge: true
              preserve_properties: true
          permissions:
            - path: /var/log/opflex
              owner: neutron:neutron
              recurse: true
            - path: /var/lib/opflex-agent-ovs
              owner: neutron:opflexep
              recurse: true
            - path: /run/opflex
              owner: neutron:neutron
              recurse: true
      docker_config_scripts: {get_attr: [ContainersCommon, container_config_scripts]}
      docker_config:
        step_4:
          ciscoaci_opflex_agent:
            start_order: 18
            image: {get_param: ContainerOpflexAgentImage}
            net: host
            pid: host
            privileged: true
            restart: always
            healthcheck:
              test: /etc/opflex-agent-ovs/opflex_healthcheck
            volumes:
              list_concat:
                - {get_attr: [ContainersCommon, volumes]}
                -
                  - /var/lib/kolla/config_files/ciscoaci_opflex_agent.json:/var/lib/kolla/config_files/config.json:ro
                  - /run/openvswitch:/run/openvswitch:shared,z
                  - /var/lib/config-data/puppet-generated/opflex/:/var/lib/kolla/config_files/src:ro
                  - /var/lib/config-data/puppet-generated/neutron/etc/neutron/neutron.conf:/etc/neutron/neutron.conf:ro
                  - /var/lib/config-data/puppet-generated/neutron/etc/neutron/metadata_agent.ini:/etc/neutron/metadata_agent.ini:ro
                  - /var/log/containers/opflex:/var/log/opflex
                  - /var/log/containers/neutron:/var/log/neutron
                  - /var/run/openvswitch/:/var/run/openvswitch/:shared,z
                  - /run/netns:/run/netns:shared
                  - /lib/modules:/lib/modules:ro
                  - /var/lib/opflex/files:/var/lib/opflex-agent-ovs:shared,z
                  - /var/lib/opflex/sockets:/run/opflex:shared,z
            environment:
              KOLLA_CONFIG_STRATEGY: COPY_ALWAYS
      host_prep_tasks:
            - name: create /run/netns with temp namespace
              command: ip netns add ns_temp
              register: ipnetns_add_result
              ignore_errors: True
            - name: remove temp namespace
              command: ip netns delete ns_temp
              ignore_errors: True
              when: ipnetns_add_result.rc == 0

            - name: Check for opflex persistent directory structure
              stat:
                path: /var/lib/opflex
              register: opflex_path

            - block:
              - name: create persistent directories
                file:
                  path: "{{ item.path }}"
                  state: directory
                  setype: "{{ item.setype }}"
                  mode: "{{ item.mode|default(omit) }}"
                with_items:
                  - { 'path': /var/lib/opflex/files/endpoints, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/files/services, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/files/ids, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/files/mcast, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/files/droplog, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/files/faults, 'setype': svirt_sandbox_file_t }
                  - { 'path': /var/lib/opflex/sockets, 'setype': svirt_sandbox_file_t }
              when:
                - not opflex_path.stat.exists

            - name: create persistent logs directory for cisco opflex agent
              file:
                path: /var/log/containers/opflex
                state: directory

            - name: get opflex interface type
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::opflex_interface_type
              register: oit
            - name: set opflex_interface_type fact
              set_fact:
                 opflex_interface_type: "{{ oit.stdout }}"

            - name: get opflex interface mtu
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::opflex_interface_mtu
              register: oimtu
            - name: set opflex_interface_mtu fact
              set_fact:
                 opflex_interface_mtu: "{{ oimtu.stdout }}"

            - name: get opflex target bridge to patch
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::opflex_target_bridge_to_patch
              register: otbtp
            - name: set opflex_target_bridge_to_patch fact
              set_fact:
                 opflex_target_bridge_to_patch: "{{ otbtp.stdout }}"

            - name: get neutron external bridge
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::neutron_external_bridge
              register: neb
            - name: set neutron_external_bridge fact
              set_fact:
                 neutron_external_bridge: "{{ neb.stdout }}"

            - name: get opflex encap mode
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::aci_opflex_encap_mode
              register: oemode
            - name: set aci_opflex_encap_mode fact
              set_fact:
                 aci_opflex_encap_mode: "{{ oemode.stdout }}"

            - name: get apic infra vlan
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::aci_apic_infravlan
              register: aai
            - name: set aci_apic_infravlan fact
              set_fact:
                 aci_apic_infravlan: "{{ aai.stdout }}"

            - name: get apic systemid
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::aci_apic_systemid
              register: asid

            - name: set aci_apic_systemid fact
              set_fact:
                 aci_apic_systemid: "{{ asid.stdout }}"

            - name: get opflex uplink interface
              command: hiera -c /etc/puppet/hiera.yaml ciscoaci::opflex::aci_opflex_uplink_interface
              register: oui
            
            - set_fact:
                 raw_u_intf: "{{ oui.stdout }}"

            - name: get mapped interface
              command: "os-net-config -i {{ raw_u_intf }}"
              register: intf_out
              ignore_errors: true
            
            - set_fact:
                 intf_json: "{{ intf_out.stdout | to_json }}"

            - name: set aci_opflex_uplink_interface fact
              set_fact:
                 aci_opflex_uplink_interface: "{{ item.value }}"
              when: item.key is defined and item.key == raw_u_intf
              with_dict: "{{ intf_json | from_json }}"

            - set_fact:
                 aci_opflex_uplink_interface: "{{ oui.stdout }}"
              when: aci_opflex_uplink_interface is not defined
       
            - name: setup infra interface file ovs type
              copy:
                dest: "/etc/sysconfig/network-scripts/ifcfg-{{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}"
                content: "DEVICE={{ aci_opflex_uplink_interface}}.{{ aci_apic_infravlan }} \nONBOOT=yes \nNM_CONTROLLED=no \nBOOTPROTO=dhcp \nDEVICETYPE=ovs \nTYPE=OVSIntPort \nOVS_BRIDGE=br-ex \nOVS_OPTIONS=\"tag={{ aci_apic_infravlan }}\" \nPEERDNS=no \nPERSISTENT_DHCLIENT=1 \nDHCPRELEASE=1 \nHOTPLUG=no \nMTU={{ opflex_interface_mtu }}"
              register: infra_interface
              when:
                - opflex_interface_type == "ovs"

            - name: setup infra interface file linux type
              copy:
                dest: "/etc/sysconfig/network-scripts/ifcfg-{{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}"
                content: "DEVICE={{ aci_opflex_uplink_interface}}.{{ aci_apic_infravlan }} \nONBOOT=yes \nNM_CONTROLLED=no \nBOOTPROTO=dhcp \nVLAN=yes \nPEERDNS=no \nPERSISTENT_DHCLIENT=1 \nDHCPRELEASE=1 \nONPARENT=yes \nMTU={{ opflex_interface_mtu }}"
              register: infra_interface
              when:
                - opflex_interface_type == "linux"

            - name: setup infra interface route file
              copy:
                dest: "/etc/sysconfig/network-scripts/route-{{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}"
                content: "224.0.0.0/4 via 0.0.0.0 dev {{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}"


            - name: get mac address for uplink interface
              command: "cat /sys/class/net/{{ aci_opflex_uplink_interface }}/address"
              register: mac_addr

            - name: setup infra interface dhcp file
              copy:
                dest: "/etc/dhcp/dhclient-{{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}.conf"
                content: "send dhcp-client-identifier 01:{{ mac_addr.stdout }};"
              register: infra_dhcp_file

            - name: bring down infra interface
              command: "/sbin/ifdown {{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }} "
              when: infra_dhcp_file is changed or infra_interface is changed

            - name: bring up infra interface
              command: "/sbin/ifup {{ aci_opflex_uplink_interface }}.{{ aci_apic_infravlan }}"
              when: infra_dhcp_file is changed or infra_interface is changed

            - name: setup br-fabric bridge
              command: "/bin/ovs-vsctl -- --may-exist add-br br-fabric"

            - name: set external id for br-fabric
              command: "/bin/ovs-vsctl br-set-external-id br-fabric bridge-id br-fabric"

            - name: set openflow version for br-fabric
              command: "/bin/ovs-vsctl set bridge br-fabric protocols=[]"

            - name: set br-fabric link up
              command: "ip link set dev br-fabric up"

            - name: Pause for 5 sec
              wait_for:
                timeout: 5

            - name: set patch from br-fabric to "{{ neutron_external_bridge }}"
              command: "/bin/ovs-vsctl -- --may-exist add-port br-fabric patch-fab-ex -- set Interface patch-fab-ex type=patch options:peer=patch-ex-fab"
              when:
                - aci_opflex_encap_mode == "vxlan"

            - name: set patch from br-ex to br-fabric
              command: "/bin/ovs-vsctl -- --may-exist add-port {{ neutron_external_bridge }}  patch-ex-fab -- set Interface patch-ex-fab type=patch options:peer=patch-fab-ex"
              when:
                - aci_opflex_encap_mode == "vxlan"

            - name: remove any old br-int_vxlan0 port
              command: "/bin/ovs-vsctl -- --if-exists del-port br-int br-int_vxlan0"
              when:
                - aci_opflex_encap_mode == "vxlan"
            - name: add br-fab_vxlan0 port
              command: "/bin/ovs-vsctl -- --may-exist add-port br-fabric br-fab_vxlan0 -- set Interface br-fab_vxlan0 type=vxlan options:remote_ip=flow options:key=flow options:dst_port=8472"
              when:
                - aci_opflex_encap_mode == "vxlan"

            - name: setup br-int bridge
              command: "/bin/ovs-vsctl -- --may-exist add-br br-int"

            - name: set external id for br-int
              command: "/bin/ovs-vsctl br-set-external-id br-int bridge-id br-int"

            - name: set openflow version for br-int
              command: "/bin/ovs-vsctl set bridge br-int protocols=[]"

            - name: set br-int link up
              command: "ip link set dev br-int up"

            - name: add droplog gen1 port
              command: "/bin/ovs-vsctl -- --may-exist add-port br-fabric gen1 -- set interface gen1 type=geneve options:remote_ip=flow options:key=1"

            - name: set gen1 ingreess policing rate
              command: "sudo ovs-vsctl set interface gen1 ingress_policing_rate=1000"

            - name: set gen1 ingreess policing burst
              command: "sudo ovs-vsctl set interface gen1 ingress_policing_burst=100"

            - name: add droplog gen2 port
              command: "/bin/ovs-vsctl -- --may-exist add-port br-int gen2 -- set interface gen2 type=geneve options:remote_ip=flow options:key=2"

            - name: set gen2 ingreess policing rate
              command: "sudo ovs-vsctl set interface gen2 ingress_policing_rate=1000"

            - name: set gen2 ingreess policing burst
              command: "sudo ovs-vsctl set interface gen2 ingress_policing_burst=100"

            # patch port when encap is vlan
            - set_fact:
                ppname: "{{ opflex_target_bridge_to_patch[0:5] }}"

            - name: set patch from br-fabric to {{ opflex_target_bridge_to_patch }}
              command: "/bin/ovs-vsctl -- --may-exist add-port br-fabric br-fa_to_{{ ppname }} -- set Interface br-fa_to_{{ ppname }} type=patch options:peer={{ ppname }}_to_br-fa"
              when:
                - opflex_target_bridge_to_patch != ''
                - aci_opflex_encap_mode == "vlan"

            - name: set patch from {{ opflex_target_bridge_to_patch }} to br-fabric
              command: "/bin/ovs-vsctl -- --may-exist add-port {{ opflex_target_bridge_to_patch }} {{ ppname }}_to_br-fa -- set Interface {{ ppname }}_to_br-fa type=patch options:peer=br-fa_to_{{ ppname }}"
              when:
                - opflex_target_bridge_to_patch != ""
                - aci_opflex_encap_mode == "vlan"
      external_upgrade_tasks:
        - when:
            - step|int == 1
          tags:
            - never
            - system_upgrade_transfer_data
            - system_upgrade_stop_services
          block:
            - name: Stop opflex container
              import_role:
                name: tripleo-container-stop
              vars:
                tripleo_containers_to_stop:
                  - ciscoaci_opflex_agent
                tripleo_delegate_to: "{{ groups['neutron_api'] | default([]) }}"

